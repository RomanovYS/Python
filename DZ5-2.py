# Написать программу сложения и умножения двух положительных целых шестнадцатеричных чисел. При этом каждое число
# представляется как коллекция, элементы которой — цифры числа. Например, пользователь ввёл A2 и C4F.
# Нужно сохранить их как [‘A’, ‘2’] и [‘C’, ‘4’, ‘F’] соответственно. Сумма чисел из примера: [‘C’, ‘F’, ‘1’],
# произведение - [‘7’, ‘C’, ‘9’, ‘F’, ‘E’].

import collections as coll

res = coll.deque()  # очередь результата
ch = coll.deque('0123456789ABCDEF')


# замена опечаток на 0 (пробная функция)
def no_err(z):  # теоретически здесь можно организовать интеллектуальную замену на близлежащие символы
    a = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'}
    for j in enumerate(z):
        if j[1] not in a:
            z[j[0]] = '0'
            print('Опечатка заменена на 0')
    return z


def align(x, y):  # принимаем на вход две очереди
    l1, l2 = len(x), len(y)  # опрделяем где сколько цифр
    if len(x) > len(y):  # если необходимо, выравниваем количество знаков
        y.extendleft('0' * (l1 - l2))
    elif len(y) > len(x):
        x.extendleft('0' * (l2 - l1))
    return x, y  # возвращаем две очереди с одинаковым количеством символов

# вынесено в отдельную функцию в процессе вариаций кода, можно спрятать в нижеследующую
def hex_sum(a, b, c):  # слагаемое 1 + слагаемое 2 + CARRY
    d = a + b + c  # вычисляем сумму позиций с учётом переноса
    if d < 16:
        return d, 0  # возвращаем сумму и отсутствие переноса разряда
    else:
        return d - 16, 1  # возвращаем сумму за вычетом основания и перенос разряда


def my_sum(deq1, deq2):
    res_sum = coll.deque()
    c = 0  # при первом сложении, переноса нет
    for i in range(len(deq1) - 1, -1, -1):  # идём в цикле по очереди в обратном порядке
        s, c = hex_sum(ch.index(deq1[i]), ch.index(deq2[i]), c)  # получаем сумму позиций символов и (есть/нет) переноса
        res_sum.appendleft(ch[s])  # заносим символ в результат
    if c > 0:  # если бит переноса больше 0 при последнем сложении
        res_sum.appendleft(ch[c])  # добавляем его в старший разряд
    return res_sum


# вводим и преобразовываем числа в свои очереди
# op1 = coll.deque(input('Введите первое число:').upper())  # операнд 1
# op2 = coll.deque(input('Введите второе число:').upper())  # операнд 2
op1 = coll.deque('A2')
op2 = coll.deque('C4F')
op1, op2 = align(no_err(op1), no_err(op2))  # подготовка цифр (удаление опечаток и выравнивание количества символов)

# ****************************** сложение ******************************
print('Результат сложения:', my_sum(op1, op2))

# ****************************** умножение ******************************
res.append('0')  # сохраняем предварительно 0 в очереди результата
while len(op2) > 0:  # пока не закончились цифры во множителе, делаем дело
    for i in range(ch.index(op2.pop())):  # берём цифру и смотрим какому числу она соответсвует... количество итераций
        res, op1 = align(res, op1)  # перед сложением уравниваем размерность если нужно (чтобы не выйти за диапазон)
        res = my_sum(res, op1)  # складываем
    op1.append('0')  # увеличиваем порядок множимого для следующей цифры множителя

print('Результат умножения:', res)
