# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
# Проанализировать результат и определить программы с наиболее эффективным использованием памяти
# Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
# ● выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
# ● написать 3 варианта кода (один у вас уже есть);
# ● проанализировать 3 варианта и выбрать оптимальный;
# ● результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом.
# Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
# ● написать общий вывод: какой из трёх вариантов лучше и почему.
# Надеемся, что вы не испортили программы, добавив в них множество sys.getsizeof после каждой переменной,
# а проявили творчество, фантазию и создали универсальный код для замера памяти.

import random as rnd
import sys


def z(dd):  # size definition (на вход словарь из переменных и их значений)
    s = 0
    print(dd)
    for i in dd.keys():  # перебираем ключи в словаре
        vz = sys.getsizeof(i)  # определяем размер переменной
        s += vz  # суммируем сумму
        print('Переменная:', i, 'занимает', vz, 'байт')
    return s  # возвращаем сумму


def variant1(r):
    for _ in range(r):
        n = rnd.randint(1_000_000_000_000_000, 9_999_999_999_999_999)  # генерим число
        k = 0
        while n > 0:  # идём по циклу пока есть от чего откусывать
            d = n % 10  # получаем цифру младшего разряда числа
            k = (k + d) * 10  # прибавляем полученную цифру и умножаем на 10 (увеличиваем разрядность)
            n //= 10  # уменьшаем число в 10 раз
        k = int(k / 10)  # корректируем последний (лишний) шаг умножения
    return vars()


def variant2(r):
    for _ in range(r):
        n = rnd.randint(1_000_000_000_000_000, 9_999_999_999_999_999)  # генерим число
        s = str(n)  # преобразовываем в строку для возможности итерации (перебора) знаков
        s = s[::-1]  # разворот строки через срез
        k = int(s)  # приводим строку к числу, т.к. на выходе должно быть число
    return vars()


def variant3(r):
    for _ in range(r):
        n = rnd.randint(1_000_000_000_000_000, 9_999_999_999_999_999)  # генерим число
        s = str(n)  # преобразовываем в строку для возможности итерации (перебора) знаков
        l = list(s)  # приводим строку к изменяемому списку
        s = ''.join(reversed(l))  # переворачиваем список и объединяем его в строку
        k = int(s)  # приводим строку к числу, т.к. на выходе должно быть число
    return vars()


print('*' * 30, 'Вариант 1', '*' * 30)
print('Переменные варианта 1 занимают суммарно:', z(variant1(100)), 'байт')
print('*' * 30, 'Вариант 2', '*' * 30)
print('Переменные варианта 1 занимают суммарно:', z(variant2(100)), 'байт')
print('*' * 30, 'Вариант 3', '*' * 30)
print('Переменные варианта 1 занимают суммарно:', z(variant3(100)), 'байт')

# Windows 10 Home, Python 3.8

# ****************************** Вариант 1 ******************************
# {'r': 100, '_': 99, 'n': 0, 'k': 2936772659510256, 'd': 6}
# Переменная: r занимает 26 байт
# Переменная: _ занимает 26 байт
# Переменная: n занимает 26 байт
# Переменная: k занимает 26 байт
# Переменная: d занимает 26 байт
# Переменные варианта 1 занимают суммарно: 130 байт
# ****************************** Вариант 2 ******************************
# {'r': 100, '_': 99, 'n': 8288233264046657, 's': '7566404623328828', 'k': 7566404623328828}
# Переменная: r занимает 26 байт
# Переменная: _ занимает 26 байт
# Переменная: n занимает 26 байт
# Переменная: s занимает 26 байт
# Переменная: k занимает 26 байт
# Переменные варианта 1 занимают суммарно: 130 байт
# ****************************** Вариант 3 ******************************
# {'r': 100, '_': 99, 'n': 1333512550214321, 's': '1234120552153331', 'l': ['1', '3', '3', '3', '5', '1', '2', '5', '5', '0', '2', '1', '4', '3', '2', '1'], 'k': 1234120552153331}
# Переменная: r занимает 26 байт
# Переменная: _ занимает 26 байт
# Переменная: n занимает 26 байт
# Переменная: s занимает 26 байт
# Переменная: l занимает 26 байт
# Переменная: k занимает 26 байт
# Переменные варианта 1 занимают суммарно: 156 байт

# Вариант 2 получается самым оптимальным, как по скорости испалнения, так и по занимаемой памяти переменными
