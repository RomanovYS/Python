# Отсортируйте по возрастанию методом слияния одномерный вещественный массив,
# заданный случайными числами на промежутке [0; 50). Выведите на экран исходный и отсортированный массивы.

import random as rnd

N = 9  # количество элементов массива
arr = [(rnd.uniform(0, 49.999)) for _ in range(N)]
# "кривой" список для проверки
# arr = [17.923771490582606, 11.907218521437427, 41.28098830132892, 17.43734060450295,
#        7.351861170527943, 10.752086929104122, 13.249117940019536, 2.5124125175549943, 14.781584219206568]

def bubble_sort(in_arr):  # предварительная сортировка подмассивов
    end_flag = True  # для входа в цикл
    while end_flag:
        end_flag = False  # принудительное окончание цикла while... если ВДРУГ не случится обмена элементов
        for i in range(
                len(in_arr) - 1):  # делаем проход по массиву c первого, а не с нулевого элемента до предпоследнего
            if in_arr[i] > in_arr[i + 1]:  # проверяем элементы справа
                tmp = in_arr[i]
                in_arr[i] = in_arr[i + 1]
                in_arr[i + 1] = tmp
                end_flag = True  # СЛУЧИЛОСЬ... есть обмен, пока не заканчиваем
    return in_arr


#
def merge_sort(a, b):
    res_arr = []  # результирующий массив
    seek_a, seek_b = 0, 0  # указатели на элемент в списках
    while True:  # Вечный цикл
        if a[seek_a] < b[seek_b]:  # если элемент в списке А меньше,
            res_arr.append(a[seek_a])  # сохраняем его в результирующий список
            seek_a += 1  # увеличиваем указаетль списка А
        elif b[seek_b] < a[seek_a]:  # если элемент в списке В меньше,
            res_arr.append(b[seek_b])  # сохраняем его в результирующий список
            seek_b += 1  # увеличиваем указаетль списка В
        if seek_a == len(a):  # если указатель списка А достиг размерности списка, дальше сравнивать нечего
            res_arr.extend(b[seek_b:])  # прицепляем к результату хвост из списка В
            break  # покидаем цикл
        elif seek_b == len(b):  # если указатель списка В достиг размерности списка, дальше сравнивать нечего
            res_arr.extend(a[seek_a:])  # прицепляем к результату хвост из списка А
            break  # покидаем цикл
    return res_arr


print('*' * 50, '\nНачальный массив\n', arr)
# делим исходный массив на 2 подмассива
arr_a = arr[:len(arr) // 2]
arr_b = arr[len(arr) // 2:]

print('Подмассив А -   ', arr_a)
arr_a = bubble_sort(arr_a)
print('Предв.сорт. А - ', arr_a)

print('Подмассив B -   ', arr_b)
arr_b = bubble_sort(arr_b)
print('Предв.сорт. B - ', arr_b)

print('*' * 50, '\nНачальный массив\n', arr)
print('Массив после merge-сортировки\n', merge_sort(arr_a, arr_b))
