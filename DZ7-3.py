# Массив размером 2m + 1, где m — натуральное число, заполнен случайным образом. Найдите в массиве медиану.
# Медианой называется элемент ряда, делящий его на две равные части: в одной находятся элементы, которые не
# меньше медианы, в другой — не больше медианы.
# Примечание: задачу можно решить без сортировки исходного массива. Но если это слишком сложно, используйте метод
# сортировки, который не рассматривался на уроках (сортировка слиянием также недопустима).

import random as rnd

N = 11  # количество элементов не чётное
arr = [(rnd.randint(-100, 99)) for _ in range(N)]
print(arr)


# код из задачи 1, сугубо в проверочных целях
def bubble_sort(in_arr):  # для массива больше 2х элементов !!!!!!!!!!!!! (т.к. цикл не с нуля)
    for_loop = len(in_arr) - 1  # цикл будет до предпоследнего элемента
    end_flag = True  # для входа в цикл
    while end_flag:
        end_flag = False  # принудительное окончание цикла while... если ВДРУГ не случится обмена элементов
        for i in range(1, for_loop):  # делаем проход по массиву c первого, а не с нулевого элемента до предпоследнего
            if in_arr[i - 1] < in_arr[i]:  # проверяем элементы слева
                arr[i - 1], arr[i] = arr[i], arr[i - 1]
                end_flag = True  # СЛУЧИЛОСЬ... есть обмен, пока не заканчиваем
            if in_arr[i] < in_arr[i + 1]:  # проверяем элементы справа
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                end_flag = True  # СЛУЧИЛОСЬ... есть обмен, пока не заканчиваем
    return in_arr


# при наличии возле "центра" массива нескольких одинаковых элементов, медиана не находится
n = len(arr)  # размерность массива для циклов
for i in range(n):  # указатель на первый элемент сравнения
    l, r = 0, 0  # обнуляем счётчики "левый" и "правый"
    for j in range(n):  # указатель на второй элемент сравнения
        if arr[i] < arr[j]:  # если первый элемент меньше
            l += 1  # увеличиваем "левый" счётчик
        elif arr[i] > arr[j]:  # если первый элемент больше
            r += 1  # увеличиваем "правый" счётчик
    print(l, r)
    if l == r:  # если количество элементов слева и справа одинаково
        print(arr[i], '- медиана')  # значит нашли центральный элемент
        break  # покидаем внешний цикл

print(bubble_sort(arr))  # вызываем сортировку из первого задания для проверки ответа

# [-22, -18, -50, 15, 80, -16, 82, 40, -23, 54, -62]
# 7 3
# 6 4
# 9 1
# 4 6
# 1 9
# 5 5
# -16 - медиана
# [82, 80, 54, 40, 15, -16, -18, -22, -23, -50, -62]
